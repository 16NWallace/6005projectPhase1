package pingballClient.parser;

/**
 * @author asolei
 */
import java.util.*;
import java.io.*;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

import physics.*;
import physics.Geometry.*;
import pingball.*;
import pingballClient.*;
import pingballClient.boardObjects.*;

/**
 * Class with which we will be able to create a Board from an input file, based on the 
 *     abstract syntax tree generated by ANTLR.
 * @author asolei
 * Implemented by: asolei
 *
 */
public class BoardFactory {
    
    /**
     * Take a File as input and generate a Board from this file. 
     * @param input File corresponding to the board to be constructed
     * @throws IOException 
     * @return Board the Board generated from the input File.
     * @author asolei
     */
    public static Board parse(File input) throws IOException{
        // Create a file reader for the input. 
        CharStream stream;
        
        try {
            // Create a stream of tokens using the lexer
            String path = input.getAbsolutePath();
            stream = new ANTLRFileStream(path);
            BoardLexer lexer = new BoardLexer(stream);
            lexer.reportErrorsAsExceptions();
            TokenStream tokens = new CommonTokenStream(lexer);
            
            // Feed the tokens into the parser
            BoardParser parser = new BoardParser(tokens);
            parser.reportErrorsAsExceptions();
            
            // Generate the parse tree using the starter rule
            ParseTree tree = parser.file();
            
            // constract a Board by walking over the parse tree
            ParseTreeWalker walker = new ParseTreeWalker();
            BoardCreatorListener listener = new BoardCreatorListener();
            walker.walk(listener, tree);
            
            // return the Board that the BoardCreatorListener created
            return listener.getBoard();
            
        } catch (FileNotFoundException e) {
            throw new FileNotFoundException("No Board found.");
        } 
    }
    
    /**
     * Listener class with which we will be able to walk the ANTLR parse tree,
     *   and extract meaningful information of the parse tree in order to generate a Board.
     * @author asolei
     *
     */
    private static class BoardCreatorListener extends BoardBaseListener {
        // HashMap to store the critical information of all the Gadgets before we create them 
        private HashMap<String, ArrayList<String>> gadgetsInfo = new HashMap<String, ArrayList<String>>();
        // List of Gadgets which will be used to create the Board
        private List<Gadget> gadgets = new ArrayList<Gadget>(); 
        // List of Balls which will be used to create the Board
        private List<Ball> balls = new ArrayList<Ball>();
        // Set of names in order to ensure that all the names in the input file are unique
        private Set<String> names = new HashSet<String>();
        // Set which will keep track of which Gadgets are self-triggering
        private Set<String> selfTriggers = new HashSet<String>();
        // Map gadget names to Gadgets created when exiting a Gadget node
        private HashMap<String, Gadget> namesToGadgets = new HashMap<String, Gadget>();
        
        // characteristics of the Board we are about to create
        private String boardName;
        private double boardGravity;
        private double boardFriction1;
        private double boardFriction2;
        
        // default values for gravity and friction
        private static double GRAVITY = 25;
        private static double FRICTION1 = 0.025;
        private static double FRICTION2 = 0.025;
        
        /**
         * Extracts the value following an equals symbol from a TerminalNode with text of the form 
         *   "var" +  WHITESPACE + "=" + WHITESPACE + "value"
         * @param info must be of the form var=value
         * @return value
         * @author asolei
         */
        private String extractVal(TerminalNode info){
            return info.getText().split("=")[1].trim();
        }
        
        /**
         * Determines if a Ball with a given name, center and velocity represents a valid ball within an input file.
         * The condition for a valid ball is as follows:
         *      within the file the name must be unique
         *      the center of the ball must be contained within the dimension of the 20x20 board
         *      the speed (magnitude of the velocity vector) of the ball is >= 0 and <= 200
         * @param name the name of the ball 
         * @param x the x coordinate of the ball's center
         * @param y the y coordinate of the ball's center
         * @param velocity the velocity vector of the ball. 
         * @return whether or not the Ball is a valid ball 
         * @author asolei
         */
        private boolean validBall(String name, double x, double y, Vect velocity){
            // check if the name is unique
            boolean validName = !names.contains(name);
            // valid locations for a Ball in the board
            boolean validCoords = (0 <= x && x < 20 && 0 <= y && y < 20);
            double speed = Math.sqrt(Math.pow(velocity.x(), 2) + Math.pow(velocity.y(), 2));
            // the bounds on speed as specified in the pset prompt
            boolean validVelocity = (0 <= speed && speed <= 200);
            return (validName && validCoords && validVelocity);
        }
        
        /**
         * Determines if a standard Gadget (bumper) represented by a given name and location for the top-left corner represents 
         * a valid gadget within an input file. 
         * The condition for a valid bumper is as follows:
         *      within the file the name must be unique
         *      the top-left corner must represent a valid placement for a gadget within the 20x20 board, where the farthest
         *        from the origin that a gadget can be placed is the location (19, 19)
         * @param name
         * @param xVal
         * @param yVal
         * @return whether or not the Gadget represented by a name and a location is valid for the input file
         * @author asolei
         */
        private boolean validGadget(String name, String xVal, String yVal){
            double x = Double.parseDouble(xVal);
            double y = Double.parseDouble(yVal);     
            // check if the name is unique
            boolean validName = !names.contains(name);
            // furthest possible location for a gadget with 1Lx1L bounding box is (19,19)
            boolean validCoords = (0 <= x && x < 20 && 0 <= y && y < 20);
            return (validName && validCoords);   
        }
        
        /**
         * Determines if an Absorber represented by a given name, location for the top-left corner, width, and height represents
         * a valid Absorber within an input file.
         * The condition for a valid Absorber is as follows:
         *      within the file the name must be unique
         *      the top-left corner must represent a valid placement for a gadget within the 20x20 board
         *      the Absorber must not extend off the board in any direction
         * @param name
         * @param xVal
         * @param yVal
         * @param widthVal
         * @param heightVal
         * @return whether or not the represented Absorber is valid
         * @author asolei
         */
        private boolean validAbsorber(String name, String xVal, String yVal, String widthVal, String heightVal){
            double x = Double.parseDouble(xVal);
            double y = Double.parseDouble(yVal);
            double width = Double.parseDouble(widthVal);
            double height = Double.parseDouble(heightVal);
            // check if name is unique
            boolean validName = !names.contains(name);
            // check if top left corner is within the board
            boolean validCoords = (0 <= x && x < 20 && 0 <= y && y < 20);
            // check if the Absorber is extending off the board in the vertical direction
            if ((y + height) > 20){
                return false;
            }
            // check if the Absorber is extending off the board in the horizontal direction
            if ((x + width) > 20){
                return false;
            } 
            // now we can return the value of validName AND validCoords 
            return (validName && validCoords);
        }
        
        /**
         * Determines if a Flipper represented by a given name and a location for the top-left corner of the bounding box
         * represents a valid Flipper within the board.
         * The condition for a valid flipper is as follows:
         *      within the input file the name must be unique
         *      the top-left corner of the bounding box must be located within the board, and must be positioned such that
         *         no part of the 2Lx2L bounding box of the flipper extends off the board 
         * @param name
         * @param xVal
         * @param yVal
         * @return whether or not the represented Flipper is valid
         * @author asolei
         */
        private boolean validFlipper(String name, String xVal, String yVal){
            double x = Double.parseDouble(xVal);
            double y = Double.parseDouble(yVal);
            // check if names is unique
            boolean validName = !names.contains(name);
            // check if bounding box will be contained within the board based on the top left corner
            boolean validFlipperCoords = (0 <= x && x <= 18 && 0 <= y && y <= 18);
            return (validName && validFlipperCoords);
        }
        
        /**
         * Determines if a trigger-action relationship between two Gadget names is valid. Both names must be contained
         *   within the file. Referencing an object that does not exist within the file is invalid.
         * @param trigger gadget name that triggers
         * @param action gadget name of action
         * @return true if both names are contained within the file
         * @throws IllegalArgumentException if a name outside of the board is referenced.
         * @author asolei
         */
        private boolean validTriggerAction(String trigger, String action) throws IllegalArgumentException{
            if (!names.contains(trigger) || !names.contains(action)){
                throw new IllegalArgumentException("Must reference names that are in the board. ");
            }
            return true;
        }
        
        /**
         * Determines if a trigger-action relationship between two Gadget names is a valid self-trigger relationship. 
         *    The values of trigger and action must be equal and must be contained within the file. 
         * @param trigger gadget name that we triggers
         * @param action gadget name of action
         * @return true if trigger-action represent a valid self-triggering relationship
         * @throws IllegalArgumentException if a name outside of the board is referenced.
         * @author asolei
         */
        private boolean selfTriggerAction(String trigger, String action) throws IllegalArgumentException{
            if (!names.contains(trigger) || !names.contains(action)){
                throw new IllegalArgumentException("Must reference names that are in the board. ");
            }
            boolean selfTrigger = (trigger.equals(action));
            return (selfTrigger);
        }
        
        /**
         * Exit a board node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed. 
         * @author asolei
         */
        @Override
        public void exitBoard(BoardParser.BoardContext ctx) {
            // get the name, add it to the set of names seen in the file, and set the boardName field to this value
            String name = extractVal(ctx.NAMEVAL());
            names.add(name);
            boardName = name;
            
            // extract and set the value for gravity. if a value is not specified,
            //    set the boardGravity to the default value
            if (ctx.GRAVITY() != null){
                double gravity = Double.parseDouble(extractVal(ctx.GRAVITY()));
                boardGravity = gravity;
            } else {
                boardGravity = GRAVITY;
            } 
            // extract and set the value for friction1. if a value is not specified,
            //      set the boardFriction1 to the default value
            if (ctx.FRICTION1() != null){
                double friction1 = Double.parseDouble(extractVal(ctx.FRICTION1()));
                boardFriction1 = friction1;
            } else {
                boardFriction1 = FRICTION1;
            } 
            // extract and set the value for friction2. if a value is not specified,
            //      set the boardFriction2 to the default value
            if (ctx.FRICTION2() != null){
                boardFriction2 = Double.parseDouble(extractVal(ctx.FRICTION2()));
            } else {
                boardFriction2 = FRICTION2;
            } 
        }
        
        /**
         * Exit a ball node generated by the parser. Extract information from the node and update the listener's fields 
         *    as needed.
         * @throws IllegalArgumentException if the information from the node represents an invalid ball
         * @author asolei
         */
        @Override
        public void exitBall(BoardParser.BallContext ctx) throws IllegalArgumentException{
            // extract the name, xval, yval, xvel, yvel from the node, construct a new velocity vector
            String ballName = extractVal(ctx.NAMEVAL());
            double ballX = Double.parseDouble(extractVal(ctx.XVAL()));
            double ballY = Double.parseDouble(extractVal(ctx.YVAL()));
            double ballXVel = Double.parseDouble(extractVal(ctx.XVEL()));
            double ballYVel = Double.parseDouble(extractVal(ctx.YVEL()));
            Vect ballVect = new Vect(ballXVel, ballYVel);
            
            // check if the ball will is valid. if so, add it's name to the set, and add the 
            //      Ball to the balls list. otherwise throw an exception
            
            if (validBall(ballName, ballX, ballY, ballVect)){
                names.add(ballName);
                balls.add(new Ball(ballName, ballX, ballY, ballVect));
            } else {
                throw new IllegalArgumentException("Invalid Ball in input file.");
            }
        }
        
        /** 
         * Exit a square node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed.
         * @throws IllegalArgumentException if the information from the node represents an invalid SquareBumper
         * @author asolei
         */
        @Override
        public void exitSquare(BoardParser.SquareContext ctx) throws IllegalArgumentException{
            // extract the name, gadget type, xval, yval from the node
            String squareName = extractVal(ctx.NAMEVAL());
            String type = ctx.SQUARE().getText();
            String squareX = extractVal(ctx.XVAL());
            String squareY = extractVal(ctx.YVAL());
            
            // check if this information represents a valid squareBumper. if so, add it's name to the set.
            //      add the name mapped to all of the square's information to the HashMap gadgetsInfo
            //      otherwise throw an exception
            if (validGadget(squareName, squareX, squareY)){
                names.add(squareName);
                ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, squareX, squareY));
                gadgetsInfo.put(squareName, info);
                getGadget(squareName);
            } else {
                throw new IllegalArgumentException("Invalid SquareBumper in input file.");
            }
        }
        
        /**
         * Exit a triangle node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed.
         * @throws IllegalArgumentException if the information from the node represents an invalid TriangleBumper
         * @author asolei
         */
        @Override
        public void exitTriangle(BoardParser.TriangleContext ctx) throws IllegalArgumentException{
            // extract the name, gadget type, xval, yval, ori from the node
            String triangleName = extractVal(ctx.NAMEVAL());
            String type = ctx.TRIANGLE().getText();
            String triangleX = extractVal(ctx.XVAL());
            String triangleY = extractVal(ctx.YVAL());
            String triangleOri = extractVal(ctx.ORI());
            
            // check if this information represents a valid triangleBumper. if so, add it's name to the set.
            //      add the name mapped to all of the triangleBumper's information to the HashMap gadgetsInfo
            //      and then construct the TriangleBumper
            if (validGadget(triangleName, triangleX, triangleY)){
                names.add(triangleName);
                ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, triangleX, triangleY, triangleOri));
                gadgetsInfo.put(triangleName, info);
                getGadget(triangleName);
            } else {
                throw new IllegalArgumentException("Invalid TriangleBumper in input file.");
            }
        }
        
        /**
         * Exit a circle node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed.
         * @throws IllegalArgumentException if the information from the node represents an invalid CircleBumper
         * @author asolei
         */
        @Override
        public void exitCircle(BoardParser.CircleContext ctx) throws IllegalArgumentException{
            // extract the name, gadget type, xval, yval from the node
            String circleName = extractVal(ctx.NAMEVAL());
            String type = ctx.CIRCLE().getText();
            String circleX = extractVal(ctx.XVAL());
            String circleY = extractVal(ctx.YVAL());
            
            // check if this information represents a valid circleBumper. if so, add it's name to the set.
            //      add the name mapped to all of the circleBumper's information to the HashMap gadgetsInfo
            //      and then construct the CircleBumper
            //      otherwise throw an exception
            if (validGadget(circleName, circleX, circleY)){
                names.add(circleName);
                ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, circleX, circleY));
                gadgetsInfo.put(circleName, info);
                getGadget(circleName);
            } else {
                throw new IllegalArgumentException("Invalid CircleBumper in input file.");
            }
        }
        
        /**
         * Exit a flipper node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed. 
         * @throws IllegalArgumentException if the information from the node represents an invalid Flipper
         * @author asolei
         */
        @Override
        public void exitFlipper(BoardParser.FlipperContext ctx) throws IllegalArgumentException{
            // determine if we have entered a left or right flipper
            if (ctx.LEFT() != null){ 
               // extract the name, gadget type, xval, yval,ori from the node
                String leftFlip = extractVal(ctx.NAMEVAL());
                String type = ctx.LEFT().getText();
                String leftFlipX = extractVal(ctx.XVAL());
                String leftFlipY = extractVal(ctx.YVAL());
                String angle = extractVal(ctx.ORI());
                
               // check if this information represents a valid leftFlipper. if so, add it's name to the set.
                //      add the name mapped to all of the leftFlipper's information to the HashMap gadgetsInfo
                //      and then construct the LeftFlipper
                //      otherwise throw an exception
                if (validFlipper(leftFlip, leftFlipX, leftFlipY)){
                    names.add(leftFlip);
                    ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, leftFlipX, leftFlipY, angle));
                    gadgetsInfo.put(leftFlip, info);
                    getGadget(leftFlip);
                } else {
                    throw new IllegalArgumentException("Invalid LeftFlipper in input file.");
                }
            } else if (ctx.RIGHT() != null){
             // extract the name, gadget type, xval, yval,ori from the node
                String rightFlip = extractVal(ctx.NAMEVAL());
                String type = ctx.RIGHT().getText();
                String rightFlipX = extractVal(ctx.XVAL());
                String rightFlipY = extractVal(ctx.YVAL());
                String angle = extractVal(ctx.ORI());
                
                // check if this information represents a valid rightFlipper. if so, add it's name to the set.
                //      add the name mapped to all of the rightFlipper's information to the HashMap gadgetsInfo
                //      and then construct the RightFlipper
                //      otherwise throw an exception
                if (validFlipper(rightFlip, rightFlipX, rightFlipY)){
                    names.add(rightFlip);
                    ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, rightFlipX, rightFlipY, angle));
                    gadgetsInfo.put(rightFlip, info);
                    getGadget(rightFlip);
                } else {
                    throw new IllegalArgumentException("Invalid RightFlipper in input file.");
                }
            }
        }
        
        /**
         * Exit an absorber node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed. 
         * @throws IllegalArgumentException if the information in the node represents an invalid absorber
         */
        @Override
        public void exitAbsorber(BoardParser.AbsorberContext ctx) throws IllegalArgumentException{
         // extract the name, gadget type, xval, yval, width, height from the node
            String absorber = extractVal(ctx.NAMEVAL());
            String type = ctx.ABS().getText();
            String absX = extractVal(ctx.XVAL());
            String absY = extractVal(ctx.YVAL());
            String width = extractVal(ctx.WIDTH());
            String height = extractVal(ctx.HEIGHT());
            
            // check if this information represents a valid Absorber. if so, add it's name to the set.
            //      add the name mapped to all of the Absorber's information to the HashMap gadgetsInfo
            //      and then construct the Absorber
            //      otherwise throw an exception
            if (validAbsorber(absorber, absX, absY, width, height)){
                names.add(absorber);
                ArrayList<String> info = new ArrayList<String>(Arrays.asList(type, absX, absY, width, height));
                gadgetsInfo.put(absorber, info);
                getGadget(absorber);
            } else {
                throw new IllegalArgumentException("Invalid Absorber in input file.");
            }
        }
        
        /** 
         * Exit a fire node generated by the parser. Extract information from the node and update the listener's fields
         *    as needed.
         * @throws IllegalArgumentException if the information in the node corresponds to an invalid trigger-action relationship
         */
        @Override
        public void exitFire(BoardParser.FireContext ctx) throws IllegalArgumentException{
            // extract the trigger name and action name from the node
            String trigger = extractVal(ctx.TRIGGER());
            String action = extractVal(ctx.ACTION());
            // if this information represents a valid self-trigger relationship, set the gadget
            //      to be self-triggering
            if (selfTriggerAction(trigger, action)){
                selfTriggers.add(trigger);
                namesToGadgets.get(trigger).setSelf();
            }
            // otherwise check if the information represents a valid trigger-action relationship
            // if valid, add the action gadget that was previously created to the list of Gadgets the trigger gadget affects
            else if (validTriggerAction(trigger, action)){
                Gadget triggerGadget = namesToGadgets.get(trigger);
                Gadget actionGadget = namesToGadgets.get(action);
                triggerGadget.addGadgets(Arrays.asList(actionGadget));
            } else {
                throw new IllegalArgumentException("Must reference Gadget in the file. ");
            }

        }
        
        
        /**
         * Given a String corresponding to a Gadget specified in the input file, generates a Gadget object
         *   reflecting the information passed in within the input file to construct the Gadget.
         * @param gadgetName corresponds to the Gadget we want to generate
         * @throws IllegalArgumentException if any information is invalid
         * @author asolei
         */
        public void getGadget(String gadgetName) throws IllegalArgumentException{
            // extract all the gadget's information from the HashMap
            ArrayList<String> gadgetInfo = gadgetsInfo.get(gadgetName);
            ArrayList<Gadget> actionGadgets = new ArrayList<Gadget>();
            
            // Gadget is assumed to not be self-triggering until otherwise specified in the input 
            //   file
            boolean selfTrigger = false;
            String type = gadgetInfo.get(0);
            
            // get the coordinates of the top left corner of the bounding box
            double xCoord = Double.parseDouble(gadgetInfo.get(1));
            double yCoord = Double.parseDouble(gadgetInfo.get(2));
            DoublePair coord = new DoublePair(xCoord, yCoord);
            
            // now use a switch-case on the gadget type to call the appropriate constructor
            // construct the appropriate gadget using all the information, and add it to the list of
            //    generated gadgets, as well as the HashMap mapping gadget names to Gadget objects
            // for the default case, which should not be reached, throw an exception
            switch (type){
            
                case "squareBumper":
                    SquareBumper square = new SquareBumper(gadgetName, coord, actionGadgets);
                    namesToGadgets.put(gadgetName, square);
                    gadgets.add(square);
                    break;
                   
                   
                case "circleBumper":
                    CircleBumper circle = new CircleBumper(gadgetName, coord, actionGadgets);
                    namesToGadgets.put(gadgetName, circle);
                    gadgets.add(circle);
                    break;
                    
                case "triangleBumper":
                    int ori = Integer.parseInt(gadgetInfo.get(3));
                    TriangleBumper triangle = new TriangleBumper(gadgetName, coord, ori, actionGadgets);
                    namesToGadgets.put(gadgetName, triangle);
                    gadgets.add(triangle);
                    break;
                    
                case "leftFlipper":
                    int angleLeft = Integer.parseInt(gadgetInfo.get(3));
                    LeftFlipper left = new LeftFlipper(gadgetName, coord, angleLeft, selfTrigger, actionGadgets);
                    namesToGadgets.put(gadgetName, left);
                    gadgets.add(left);
                    break;
                    
                case "rightFlipper":
                    int angleRight = Integer.parseInt(gadgetInfo.get(3));
                    RightFlipper right = new RightFlipper(gadgetName, coord, angleRight, selfTrigger, actionGadgets);
                    namesToGadgets.put(gadgetName, right);
                    gadgets.add(right);
                    break;
                    
                case "absorber":
                    double width = Double.parseDouble(gadgetInfo.get(3));
                    double height = Double.parseDouble(gadgetInfo.get(4));
                    Absorber abs = new Absorber(width, height, coord, gadgetName, selfTrigger, actionGadgets);
                    namesToGadgets.put(gadgetName, abs);
                    gadgets.add(abs);
                    break;
                    
                default:
                    
                    throw new IllegalArgumentException("Illegal Gadget type.");
            }
        }
        
        
        /**
         * Generates a Board that reflects all the information specified in the input file, if the information
         *    is all valid.
         * @return Board 
         * @author asolei
         */
        public Board getBoard(){
            // create a new Board from everything we have extracted
            return new Board(gadgets, balls, boardName, boardGravity, boardFriction1, boardFriction2);
        }
    }
    

    /**
     * A print listener class for debugging purposes.
     * @author asolei
     *
     */
    static class PrintEverythingListener extends BoardBaseListener {
        @Override public void enterAbsorber(BoardParser.AbsorberContext ctx) { System.err.println("entering absorber " 
                + ctx.NAMEVAL().getText());}
        @Override public void exitAbsorber(BoardParser.AbsorberContext ctx) { System.err.println("exiting absorber " 
                + ctx.NAMEVAL().getText());}

        @Override public void enterBall(BoardParser.BallContext ctx) {System.err.println("entering ball " 
                + ctx.NAMEVAL().getText()); }
        @Override public void exitBall(BoardParser.BallContext ctx) { System.err.println("exiting ball " 
                + ctx.NAMEVAL().getText());}

        @Override public void enterTriangle(BoardParser.TriangleContext ctx) {System.err.println("entering triangle " 
                + ctx.NAMEVAL().getText()); }
        @Override public void exitTriangle(BoardParser.TriangleContext ctx) { System.err.println("exiting triangle " 
                + ctx.NAMEVAL().getText());}

        @Override public void enterFlipper(BoardParser.FlipperContext ctx) { System.err.println("entering flipper " 
                + ctx.NAMEVAL().getText());}
        @Override public void exitFlipper(BoardParser.FlipperContext ctx) { System.err.println("exiting flipper " 
                + ctx.NAMEVAL().getText());}

        @Override public void enterCircle(BoardParser.CircleContext ctx) { System.err.println("entering circle " 
                + ctx.NAMEVAL().getText());}
        @Override public void exitCircle(BoardParser.CircleContext ctx) {System.err.println("exiting circle " 
                + ctx.NAMEVAL().getText()); }

        @Override public void enterSquare(BoardParser.SquareContext ctx) {System.err.println("entering square " 
                + ctx.NAMEVAL().getText()); }
        @Override public void exitSquare(BoardParser.SquareContext ctx) { System.err.println("exiting square " 
                + ctx.NAMEVAL().getText());}


        @Override public void enterBoard(BoardParser.BoardContext ctx) { System.err.println("entering board " 
                + ctx.NAMEVAL().getText());}
        @Override public void exitBoard(BoardParser.BoardContext ctx) {System.err.println("exiting board " 
                + ctx.NAMEVAL().getText()); }

        @Override public void enterFire(BoardParser.FireContext ctx) {System.err.println("entering fire " 
                + ctx.getText()); }
        @Override public void exitFire(BoardParser.FireContext ctx) {System.err.println("exiting fire " 
                + ctx.getText()); }


    }
}
